<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DCS Reference: DCS User&#39;s Manual</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DCS Reference
   &#160;<span id="projectnumber">2.4</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">DCS User's Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<title>DCS Users Manual</title>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
		<meta name="author" content="Dustin Graves">
	</head>
	<body>
		<h1>DCS User's Manual</h1>
		<h2>Edition 2.4, for DCS version 2.x<br>
		</h2>
		<h2>September 2008</h2>
		<i>by Dustin Graves, the Naval Research Laboratory</i><br>
		<br>
		<hr width="100%" size="2">
		<h2>Table of Contents</h2>
		<ul>
			<li>
				<a href="#1.0_Introduction">1.0 Introduction</a></li>
			<li>
				<a href="#2.0_Data_Types">2.0 Data Types</a></li>
			<ul>
				<li>
					<a href="#2.1_Initialization_Objects_Headers">2.1 Intialization Objects</a></li>
				<li>
					<a href="#2.2_Data_Objects">2.2 Data Objects</a></li>
				<li>
					<a href="#2.3_Global_Configuration_Objects">2.3 Global Configuration Objects</a><br>
				</li>
			</ul>
			<li>
				<a href="#3.0_Data_Containers">3.0 Data Containers</a></li>
			<li>
				<a href="#4.0_API_functionality">4.0 API Functionality</a></li>
			<ul>
				<li>
					<a href="#4.1_DCS_Server_API">4.1 DCS Server API</a></li>
				<ul>
					<li>
						<a href="#4.1.1_Server_Creation">4.1.1 Server Creation</a></li>
					<li>
						<a href="#4.1.2_Server_Initialization">4.1.2 Server Initialization</a></li>
					<li>
						<a href="#4.1.3_Accepting_Connections">4.1.3 Accepting Connections</a></li>
					<li>
						<a href="#4.1.4_Connection_Negotiation">4.1.4 Connection Negotiation</a></li>
					<li>
						<a href="#4.1.5_Data_Management_and_Transmittal">4.1.5 Data Management and 
							Transmittal</a></li>
					<li>
						<a href="#4.1.6_Server_Completion">4.1.6 Server Completion</a></li>
					<li>
						<a href="#4.1.7_Further_Reading">4.1.7 Further Reading</a></li>
				</ul>
				<li>
					<a href="#4.2_DCS_Client_API">4.2 DCS Client API</a></li>
			</ul>
			<li>
				<a href="#5.0_Server_Discovery">5.0 Server Discovery</a>&nbsp;</li>
			<ul>
				<li>
					<a href="#5.1_Discovery_Server_API">5.1 Discovery Server API</a></li>
				<li>
					<a href="#5.2_Discovery_Client_API">5.2 Discovery Client API</a><br>
				</li>
			</ul>
			<li>
				<a href="#6.0_Using_the_Library">6.0 Using the Library</a></li>
			<ul>
				<li>
					<a href="#6.1_Required_Files">6.1 Required Files</a></li>
				<li>
					<a href="#6.2_Build_Configuration">6.2 Build Configuration</a><br>
				</li>
			</ul>
		</ul>
		<br>
		<hr width="100%" size="2">
		<br>
		<h2><a name="1.0_Introduction"></a>1.0 Introduction</h2>
		The DCS API is a C++ software library developed by the Tactical Electronic 
		Warfare Division at the Naval Research Laboratory. &nbsp; The API is the 
		software implementation of a system for sending data to SIMDIS for display, 
		distributed as part of the SIMDIS 3D Visualization and Display package.&nbsp; 
		The API transmits predefined data types to SIMDIS using two standard Internet 
		Protocols (IP).&nbsp; These Internet Protocols are the Transmission Control 
		Protocol (TCP) and the User Datagram Protocol (UDP). &nbsp;<br>
		&nbsp;&nbsp; &nbsp;TCP is a protocol for reliably transmitting data from one 
		point to another.&nbsp; All data sent via TCP is guaranteed to arrive at its 
		destination, in the order in which it was sent.&nbsp; A significant amount of 
		overhead is required for the reliable delivery of information in sequence, as 
		no single piece of data may be delivered before the arrival of its 
		predecessors.&nbsp; Examples of applications that utilize the Transmission 
		Control Protocol are web browsers and email programs.&nbsp; DCS uses TCP to 
		transmit important information such as initialization and state modification 
		data types. &nbsp;<br>
		&nbsp;&nbsp; &nbsp;UDP is a non-reliable Internet Protocol that uses what can 
		be described as a "fire and forget" approach to data transmission.&nbsp; UDP 
		data is not guaranteed to arrive at its destination in sequence, or even to 
		arrive at its destination at all.&nbsp; Some examples of applications that 
		utilize the User Datagram Protocol are network timeservers, domain name 
		servers, and network video games.&nbsp; DCS uses UDP to transmit information 
		such as position updates, which are only valid during a specific time 
		frame.&nbsp; This type of data typically arrives at a very high rate, and the 
		infrequent loss of data is negligible when compared with the significant amount 
		of overhead required to reliably transmit the data in sequence. &nbsp;<br>
		<br>
		<br>
		<h2><a name="2.0_Data_Types"></a>2.0 Data Types</h2>
		DCS provides a set of data types for describing objects to be displayed by 
		SIMDIS.&nbsp; These display objects are platforms, beams, and gates.&nbsp; 
		Platform display objects represent entities such as aircraft, ships, and 
		buildings.&nbsp; Beam and gate display objects can be used to visualize data 
		from objects such as antennas, radar, and RF seekers.&nbsp; The data types used 
		to describe display objects can be separated into two separate but related 
		categories, initialization objects and data objects. &nbsp;<br>
		<br>
		<h3><a name="2.1_Initialization_Objects_Headers"></a>2.1 Initialization Objects 
			(Headers)</h3>
		Initialization objects only need to be sent once when a display object is 
		created or when a specific object characteristic needs to be modified (e.g. 
		object color).&nbsp; Transmission of initialization objects is done with 
		TCP.&nbsp; Available initialization objects are:
		<ul>
			<li>
				DCSPlatformHeader - Creates a platform object.&nbsp; Specifies call sign, 3D 
				model to display, initial position, etc. &nbsp;</li>
			<li>
				DCSBeamHeader - Creates a beam object.&nbsp; Specifies associated platform, 
				target, field of view, etc. &nbsp;</li>
			<li>
				DCSGateHeader - Creates a gate object.&nbsp; Specifies associated beam, width, 
				length, etc. &nbsp;</li>
			<li>
				DCSEvent - Modifies the state of a platform, beam, or gate object.&nbsp; 
				Changes color, beam target, etc. &nbsp;</li>
		</ul>
		<br>
		<h3><a name="2.2_Data_Objects"></a>2.2 Data Objects</h3>
		Data objects provide state information for a display object (e.g. TSPI 
		data).&nbsp; Each data object must be associated with an existing display 
		object that was created by an initialization object.&nbsp; Data objects are 
		sent as often as required.&nbsp; Transmission of data objects is done with 
		UDP.&nbsp; Available data objects are:<br>
		<ul>
			<li>
				DCSPlatformData - Provides updated TSPI data for an existing platform. &nbsp;</li>
			<li>
				DCSBeamData - Provides updated beam directional information for an existing 
				platform. &nbsp;</li>
			<li>
				DCSGateData - Provides updated gate position for an existing platform. &nbsp;</li>
			<li>
				DCSGenericData - Used to send generic items (e.g. text overlays) for display in 
				SIMDIS. &nbsp;</li>
		</ul>
		<br>
		<h3><a name="2.3_Global_Configuration_Objects"></a>2.3 Global Configuration Objects</h3>
		In addition to the data types for describing display objects, the DCS API has 
		two configuration objects.&nbsp; These configuration objects describe the 
		scenario and time configurations.&nbsp; There should be only one scenario 
		configuration object and one time configuration object.&nbsp; Each 
		configuration object has an initialization object, for configuring the client, 
		and a data object, for making updates to the time and scenario configurations:
		<ul>
			<li>
				DCSScenarioHeader - Initialization parameters for scenario.&nbsp; Specifies 
				classification, reference coordinate, etc. &nbsp;</li>
			<li>
				DCSScenarioData - Provides updates for scenario wind speed and wind direction 
				parameters. &nbsp;</li>
			<li>
				DCSTimeHeader - Initialization parameters for time.&nbsp; Specifies time source 
				(e.g. server, workstation clock), etc. &nbsp;</li>
			<li>
				DCSTimeData - Provides updates for time, if the server is acting as the time 
				source. &nbsp;</li>
		</ul>
		The DCSEvent data type can also be used to change the scenario's 
		classification. &nbsp;<br>
		<br>
		<br>
		<h2><a name="3.0_Data_Containers"></a>3.0 Data Containers</h2>
		DCS provides a data structure for storing header objects, called the 
		DCSHeaderContainer.&nbsp; The DCSHeaderContainer provides functionality for 
		inserting, updating, retrieving, and removing header objects.&nbsp; The 
		DCSHeaderContainer stores header objects in a random access file, employing a 
		balanced binary tree to index the locations of each file entry.&nbsp; The 
		balanced binary tree contains records with the id, location, and size of each 
		header object.&nbsp; When the DCSHeaderContainer accesses a header object it 
		first retrieves the object's record from the balanced binary tree, using the id 
		as a key.&nbsp; Once the header object's record has been obtained, the data 
		location and size provided by the record are used to extract the header object 
		from the random access file.&nbsp; Because the random access file containing 
		the header objects is likely to be cached in available physical memory, 
		accessing the header objects in the random access file should be roughly 
		equivalent to accessing objects in RAM.&nbsp; When the available physical 
		memory is exhausted, accessing the header objects in the random access file 
		directly from disk should be equivalent to paging virtual memory, without the 
		threat of "thrashing" or virtual memory exhaustion (available virtual memory 
		should, on average, be much smaller than available disk space). &nbsp;<br>
		&nbsp;&nbsp; &nbsp;A detailed description of the DCSHeaderContainer and its 
		components can be found in the DCS Reference Documentation.&nbsp; A 
		DCSHeaderContainer usage example appears in the DCS Server API section of this 
		document. &nbsp;<br>
		<br>
		<br>
		<h2><a name="4.0_API_functionality"></a>4.0 API functionality</h2>
		Functions from the DCS API are used to send DCS data types from a DCS server to 
		a DCS client (e.g. SIMDIS).&nbsp; The DCS API can be divided into two main 
		functional components, the DCS Server API and the DCS Client API.&nbsp; Most 
		users will be interested in only the DCS Server API, because it provides them 
		with a means for displaying their data in SIMDIS.&nbsp; The DCS Client API is 
		intended only for the use in applications like SIMDIS, which are capable of 
		displaying SIMDIS specific data types, but some users may find the DCS Client 
		API useful for developing applications to debug their DCS server or log their 
		data in a SIMDIS specific format. &nbsp;<br>
		<br>
		<h3><a name="4.1_DCS_Server_API"></a>4.1 DCS Server API</h3>
		The DCS Server API provides functionality for managing TCP connections from DCS 
		clients and distributing data to DCS clients.&nbsp; A DCS Server application 
		will listen for TCP connections from DCS Clients.&nbsp; When a client-server 
		connection is established, the DCS Server application will provide the DCS 
		Client with the information it needs for initializing time, setting up the 
		scenario, and reading the server's UDP data.&nbsp;&nbsp; The server also 
		provides the client with initialization objects for each display object for 
		which there is data.&nbsp; For this reason, the DCS Server application should 
		keep an initialization object for each data object of which it is aware. &nbsp;<br>
		<br>
		<h4><a name="4.1.1_Server_Creation"></a>4.1.1 Server Creation</h4>
		The first step in creating a DCS server is to declare a DCSCom::DCSServerInfo 
		object*.&nbsp; This object will store the state information for a server.&nbsp; 
		Once a DCSServerInfo object has been created, the functions provided by DCS API 
		can be used to manipulate it. &nbsp;<br>
		<br>
		<br>
		* For Microsoft Windows based applications this is actually the second step. 
		&nbsp;Before Windows network services may be used, an application must 
		initialize the Winsock DLL. &nbsp;A function called 'initializeSocket()' is 
		provided with the DCS API for this purpose. &nbsp;The 'initializeSocket()' 
		function should only be called once. &nbsp;A good location for the placement of 
		the 'initializeSocket' function is at the beginning of the calling program's 
		main body. &nbsp;The resources allocated for the Winsock DLL by the 
		'initializeSocket()' function should be released before program exit with the 
		'finalizeSocket()' function. &nbsp;<br>
		<br>
		<h4><a name="4.1.2_Server_Initialization"></a>4.1.2 Server Initialization</h4>
		The next step is to initialize the server and have it listen for client 
		connections.&nbsp; This is accomplished with the DCSCom::serverStart 
		function.&nbsp; Before this function can be utilized, a number for the port on 
		which the server will listen for connections must be chosen and a method for 
		the transmission of UDP data must be selected.&nbsp; An optional network 
		interface may also be selected. &nbsp;<br>
		&nbsp;&nbsp; &nbsp;The server's port number is used by TCP for accepting and 
		managing client connections.&nbsp; The port number is represented as an 
		unsigned short integer (16 bit) and may be any value in the range of 
		1024..65535 (values of 1..1023 are reserved for use with system and Internet 
		services such as HTTP and SMTP).&nbsp; Port numbers may only be used by one 
		application at a time.&nbsp; When an application is "bound" to a port number 
		such as "2020", it is granted exclusive rights to that port number by the 
		operating system. &nbsp;<br>
		&nbsp;&nbsp; &nbsp;The server's UDP mode can be general UDP unicast, or one of 
		the UDP subsets, broadcast or multicast.&nbsp; Once a UDP mode is selected, a 
		port number for the UDP data and, depending on the UDP mode, an address for the 
		UDP data must be chosen.&nbsp; The UDP port number should not be the same value 
		as the TCP port number. &nbsp;<br>
		&nbsp;&nbsp; &nbsp;When transmitting Unicast data, only a port number is 
		required. &nbsp;<br>
		&nbsp;&nbsp; &nbsp;When transmitting Broadcast data, both a port number and a 
		broadcast address are required.&nbsp; The selected broadcast address should be 
		either a valid broadcast address for a subnet to which the server's workstation 
		is connected, or the Limited Broadcast Address (255.255.255.255) which routes 
		data to the local subnet only.&nbsp; More information regarding a workstation's 
		subnet(s) and broadcast address(es) may be obtained from that workstation's 
		system administrator. &nbsp;<br>
		&nbsp;&nbsp; &nbsp;When transmitting Multicast data, both a port number and a 
		Multicast group address are required.&nbsp; A multicast address is a class D 
		network address in the range 224.0.1.0..239.255.255.255 (addresses in the range 
		224.0.0.0..224.0.0.255 are also valid multicast addresses, but are reserved for 
		low-level topology discovery and maintenance protocols, and should never be 
		used).&nbsp; In addition to a Multicast address and port, an optional Multicast 
		Time-To-Live (TTL) may be specified.&nbsp; The Multicast TTL limits the 
		distance that Multicast data may travel.&nbsp; By default, transmission of 
		Multicast data is limited to the local subnet (TTL = 1). &nbsp;<br>
		&nbsp;&nbsp; &nbsp;In addition to a server port number and a UDP mode, an 
		optional network interface may be specified.&nbsp; A network interface is a 
		device through which workstations communicate on a network.&nbsp; This device 
		is typically a Network Interface Card (NIC), or a loopback device (Microsoft 
		loopback adapter).&nbsp; A network interface is defined by its IP 
		address.&nbsp; To select a specific interface, simply set the interface value 
		to the IP address associated with that interface.&nbsp; This option is 
		particularly useful for forcing multi-homed workstations (workstations with 
		multiple NICs) to transmit DCS data on one specific interface, or for forcing 
		data to be available only to applications on the local host by specifying the 
		loopback address (127.0.0.1) as the interface.&nbsp; If no interface is 
		specified, the server will accept connections from all available interfaces. 
		&nbsp;<br>
		&nbsp;&nbsp; &nbsp;After all of the appropriate network parameters have been 
		selected, the server can be initialized with DCSCom::startServer.&nbsp; After 
		the successful completion of this function, the server will be actively 
		listening for client connections.&nbsp; An invocation of the 
		DCSCom::serverStart function might look like this:<br>
		<br>
		<br>
		<table cellpadding="2" cellspacing="0" border="1" width="750" align="center">
			<tbody>
				<tr>
					<td valign="top"><code><font color="#000099">DCSCom::DCSServerInfo</font> <font color="#cc33cc">
								server</font>;&nbsp;&nbsp; &nbsp;&nbsp; <font color="#006600">// The server.</font><br>
							<br>
							<font color="#000099">unsigned short</font> <font color="#cc33cc">server_port</font>=2525;&nbsp;&nbsp;
							<font color="#006600">// The port on which the server will accept connections.</font><br>
							<br>
							<font color="#000099">int</font> <font color="#cc33cc">udp_mode</font>=DCSDATA_MULTICAST;&nbsp;&nbsp; 
							&nbsp;<font color="#006600">// The UDP data mode.&nbsp; In this case it is 
								multicast.</font><br>
							<font color="#000099">unsigned short</font> <font color="#cc33cc">data_port</font>=6112;&nbsp;&nbsp; 
							&nbsp; <font color="#006600">// The port on which the server will send UDP data.</font><br>
							<br>
							<font color="#000099">const char</font> <font color="#cc33cc">data_addr</font>[DCS_ADDRSTRLEN]="<font color="#663366">225.0.6.112</font>";
							<font color="#006600">// A valid Multicast address.</font><br>
							<font color="#000099">const char</font> <font color="#cc33cc">*iface</font>=NULL;&nbsp;&nbsp; 
							&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<font color="#006600">/* Not specifying 
								an interface.&nbsp; Equivalent to
								<br>
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 'INADDR_ANY'.<br>
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */</font><br>
							<br>
							<font color="#000099">TTL_T</font> <font color="#cc33cc">ttl</font>=32;&nbsp;&nbsp; 
							&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#006600">/* 
								The ttl type representation differs with
								<br>
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * different network 
								implementations.&nbsp; Windows
								<br>
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * treats the ttl type as an 
								integer (32 bit)<br>
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * and UNIX treats the ttl type 
								as a byte (8 bit). &nbsp;<br>
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * With DCS, a type has been 
								created which is defined
								<br>
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * as 'int' for Windows and 
								'char' for UNIX. &nbsp;<br>
								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
								&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font><br>
							<br>
							<font color="#000099">bool</font> <font color="#cc33cc">success</font>=<font color="#ff0000">DCSCom::serverStart</font>(server,server_port,udp_mode,<br>
							&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
							&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data_port,data_addr,iface,ttl);<br>
							<font color="#3333ff">if</font>(success)<br>
							{<br>
							&nbsp; printf("<font color="#663366">DCS server now actively listening on %d\n</font>",server_port);<br>
							}<br>
							<font color="#3333ff">else</font><br>
							{<br>
							&nbsp; <font color="#006600">/* Use the DCS provided getSockErr() function to 
								retrieve an error code.&nbsp;
								<br>
								&nbsp;&nbsp; * getSockErr() returns 'errno' for UNIX and the result of 
								WSAGetLastError()
								<br>
								&nbsp;&nbsp; * for Windows. &nbsp;<br>
								&nbsp;&nbsp; */</font><br>
							&nbsp; printf("<font color="#663366">DCSCom::serverStart failed with error code: 
								%d\n</font>",getSockError());<br>
							}</code><code><br>
						</code>
					</td>
				</tr>
			</tbody>
		</table>
		<br>
		<br>
		&nbsp;&nbsp; &nbsp;This will create an instance of a DCS server, listening for 
		and accepting connections on port 2525 and transmitting data to the Multicast 
		group defined by the address "225.0.6.112" and the port 6112.&nbsp; This 
		particular server will listen for and accept connections on all available 
		interfaces (all NICs, loopback device, etc) and has a multicast TTL of 32, 
		which restricts the scope of Multicast transmission to workstations within the 
		same site (workstations on the same domain).&nbsp; &nbsp;<br>
		<br>
		<h4><a name="4.1.3_Accepting_Connections"></a> 4.1.3 Accepting Connections</h4>
		Once the server is actively listening, connections may be accepted with the 
		DCSCom::serverAccept function.&nbsp; Monitoring for and accepting connections 
		can be a tricky process, because the program will enter a suspended state while 
		it waits for connections to accept.&nbsp; For this reason, it will be necessary 
		to either accept client connections in a separate thread or poll the server 
		socket, testing for pending connections before attempting to accept a 
		connection. &nbsp;<br>
		&nbsp;&nbsp; &nbsp;Using a separate thread for accepting and negotiating 
		connections is the most efficient solution to the problem, but can be somewhat 
		complicated when negotiating a connection with a newly accepted client.&nbsp; 
		An invocation of the DCSCom::serverAccept function from a thread might look 
		like this:<br>
		<br>
		<br>
		<table cellpadding="2" cellspacing="0" border="1" width="750" align="center">
			<tbody>
				<tr>
					<td valign="top"><code><font color="#006600">/* This function defines the operation to be 
								executed by the thread. &nbsp;<br>
								&nbsp;* Because threading can be operating system specific, pseudo code is
								<br>
								&nbsp;* employed to depict typical thread-related objects.&nbsp; DCS does not 
								require any
								<br>
								&nbsp;* specific threading library, but the posix threads (pthreads) would be a 
								good<br>
								&nbsp;* library choice as it should be available with any modern UNIX 
								workstation,
								<br>
								&nbsp;* and has a Windows implementation which can be obtained at:
								<br>
								&nbsp;* http://sources.redhat.com/pthreads-win32<br>
								&nbsp;*/</font><br>
							<font color="#000099">THREAD_RETURN_TYPE</font> <font color="#000066">threadproc</font>(<font color="#000099">THREAD_ARG</font>
							<font color="#cc33cc">*data</font>)<br>
							{<br>
							&nbsp; <font color="#000099">DCSCom::DCSServerInfo</font> <font color="#cc33cc">*server</font>=(<font color="#000099">DCSCom::DCSServerInfo</font>
							*)data;<br>
							<br>
						</code><code>&nbsp; <font color="#006600">//'accept_connections' is a Boolean value 
								controlled by the program</font></code>.<code><br>
							&nbsp; <font color="#3333ff">while</font>(accept_connections)<br>
							&nbsp; {<br>
							&nbsp;&nbsp;&nbsp; <font color="#000099">SockClient</font> <font color="#cc33cc">*client</font>=<font color="#ff0000">DCSCom::serverAccept</font>(*server);<br>
							&nbsp;&nbsp; &nbsp;<font color="#3333ff">if</font>(client==NULL)<br>
							&nbsp;&nbsp; &nbsp;{<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#006600">/* Use the DCS provided 
								getSockErr() function to retrieve an error code.&nbsp;
								<br>
								&nbsp; &nbsp; &nbsp; &nbsp;* getSockErr() returns 'errno' for UNIX and the 
								result of WSAGetLastError()
								<br>
								&nbsp; &nbsp; &nbsp; &nbsp;* for Windows. &nbsp;<br>
								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</font><br>
							&nbsp;&nbsp; &nbsp;&nbsp; printf("<font color="#663366">DCSCom::serverAccept failed 
								with error code: %d\n</font>",getSockError());<br>
							&nbsp;&nbsp; &nbsp;}<br>
							&nbsp;&nbsp; &nbsp;<font color="#3333ff">else</font><br>
							&nbsp;&nbsp; &nbsp;{<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#000099">char</font> client_address[DCS_ADDRSTRLEN];<br>
							&nbsp;&nbsp; &nbsp;&nbsp; printf("<font color="#663366">Accepting connection from 
								client with address: %s\n</font>",<br>
							&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
							client-&gt;getAddress(client_address,DCS_ADDRSTRLEN));<br>
							&nbsp;&nbsp; &nbsp;}<br>
							&nbsp; }<br>
							}<br>
							<br>
							<font color="#006600">// The main program then creates a thread to execute our 
								client accept process.</font><br>
							<font color="#000099">int</font> <font color="#000066">main</font>(<font color="#000099">int</font>
							<font color="#cc33cc">argc</font>,<font color="#000099">char</font> <font color="#cc33cc">
								**argv</font>)<br>
							{<br>
							&nbsp; <font color="#006600">// Do any initialization routines.<br>
								&nbsp; // Start server.</font><br>
							&nbsp; <font color="#000099">DCSCom::DCSServerInfo</font> server;<br>
							&nbsp; ...<br>
							&nbsp; <font color="#006600">// Start thread.</font><br>
							&nbsp; THREAD_ID=<font color="#000066">THREAD_START</font>(threadproc,(<font color="#000099">THREAD_ARG</font>
							*)&amp;server);<br>
							&nbsp; ...<br>
							&nbsp; <font color="#006600">// Do work.</font><br>
							&nbsp; ...<br>
							&nbsp; <font color="#006600">// When work is done, exit program.</font><br>
							&nbsp; <font color="#000066">THREAD_STOP</font>(THREAD_ID);<br>
							&nbsp; ...<br>
							&nbsp; <font color="#006600">// Stop server.</font><br>
							&nbsp; ...<br>
							&nbsp; <font color="#3333ff">return</font> 0;<br>
							}</code>
					</td>
				</tr>
			</tbody>
		</table>
		<br>
		<br>
		&nbsp;&nbsp; &nbsp;Polling for connections is a much simpler solution to the 
		problem, but requires the program to test for pending connections at a regular 
		interval.&nbsp; An invocation of the DCSCom::serverAccept function with polling 
		might look like this:<br>
		<br>
		<br>
		<table cellpadding="2" cellspacing="0" border="1" width="750" align="center">
			<tbody>
				<tr>
					<td valign="top"><code><font color="#006600">// This example uses an infinite loop that 
								will 'exit' when the server is to be stopped.</font><br>
							<font color="#3333ff">for</font>(;;)<br>
							{<br>
							&nbsp; <font color="#006600">// 'server' is our activate DCSCom::DCSServerInfo 
								object.</font><br>
							&nbsp; <font color="#3333ff">if</font>(server.serverSocket-&gt;readReady())<br>
							&nbsp; {<br>
							&nbsp; &nbsp; <font color="#000099">SockClient</font> <font color="#cc33cc">*client</font>=<font color="#ff0000">DCSCom::serverAccept</font>(server);<br>
							&nbsp; &nbsp; <font color="#3333ff">if</font>(client==NULL)<br>
							&nbsp;&nbsp; &nbsp;{<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#006600">/* Use the DCS provided 
								getSockErr() function to retrieve an error code.&nbsp;
								<br>
								&nbsp; &nbsp; &nbsp; &nbsp;* getSockErr() returns 'errno' for UNIX and the 
								result of WSAGetLastError()
								<br>
								&nbsp; &nbsp; &nbsp; &nbsp;* for Windows. &nbsp;<br>
								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</font><br>
							&nbsp;&nbsp; &nbsp;&nbsp; printf("<font color="#663366">DCSCom::serverAccept failed 
								with error code: %d\n</font>",getSockError());<br>
							<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#006600">// Exit loop.</font><br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#3333ff">break</font>;<br>
							&nbsp;&nbsp;&nbsp; }<br>
							&nbsp;&nbsp; &nbsp;<font color="#3333ff">else</font><br>
							&nbsp;&nbsp; &nbsp;{<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#000099">char</font> <font color="#cc33cc">client_address</font>[DCS_ADDRSTRLEN];<br>
							&nbsp;&nbsp; &nbsp;&nbsp; printf("<font color="#663366">Accepting connection from 
								client with address: %s\n</font>",<br>
							&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
							client-&gt;getAddress(client_address,DCS_ADDRSTRLEN));<br>
							&nbsp; &nbsp; }<br>
							&nbsp; }<br>
							&nbsp; <font color="#006600">// Do other stuff.&nbsp; Break from loop when done.</font>
							&nbsp;<br>
							}<br>
						</code>
					</td>
				</tr>
			</tbody>
		</table>
		<br>
		<br>
		<h4><a name="4.1.4_Connection_Negotiation"></a> 4.1.4 Connection Negotiation</h4>
		After a client connection has been accepted, the connection must be 
		negotiated.&nbsp; The negotiation process first requires the client and server 
		to verify that they are using a common version of the DCS protocol.&nbsp; If 
		the protocol versions do not match, the client and server may not be able to 
		properly communicate with each other and the connection will be 
		terminated.&nbsp; Once the server has determined communication with the client 
		is feasible, it will send the client a DCSScenarioHeader object, a 
		DCSTimeHeader object, and all of the platform, beam, and gate headers contained 
		within the DCSHeaderContainer.&nbsp; The server also sends the client the 
		information required to receive UDP data; the UDP mode, data port, and data 
		address.&nbsp; Connection negotiation should be done at the same time a 
		connection is made. &nbsp;<br>
		&nbsp;&nbsp; &nbsp;As previously mentioned, connection negotiation can be 
		complicated when done from within a thread.&nbsp; A threaded program will be 
		required to provide mutually exclusive access to the DCSHeaderContainer, 
		DCSScenarioHeader, and DCSTimeHeader.&nbsp; The program must not allow the 
		DCSHeaderContainer, DCSScenarioHeader, or DCSTimeHeader to be modified while 
		being distributed to the client during connection negotiation.&nbsp; The 
		results of such an action would be undefined.&nbsp; The threaded 
		DCSCom::serverAccept example, with an invocation of the DCSCom::serverNegotiate 
		function might look like this:
		<br>
		<br>
		<br>
		<table cellpadding="2" cellspacing="0" border="1" width="750" align="center">
			<tbody>
				<tr>
					<td valign="top"><code><font color="#000099">THREAD_RETURN_TYPE</font> <font color="#000066">
								threadproc</font>(<font color="#000099">THREAD_ARG</font> <font color="#cc33cc">
								*data</font>[])<br>
							{<br>
							&nbsp; <font color="#006600">/* This time thread arg is an array of void pointers, 
								referencing the data
								<br>
								&nbsp;&nbsp; * required for negotiation.&nbsp; In actuality, this would 
								probably need to be a
								<br>
								&nbsp;&nbsp; * structure, rather than an array. &nbsp;<br>
								&nbsp;&nbsp; */</font><br>
							&nbsp; <font color="#000099">DCSCom::DCSServerInfo</font> <font color="#cc33cc">*server</font>=(<font color="#000099">DCSCom::DCSServerInfo</font>
							*)data[0];<br>
							&nbsp; <font color="#000099">DCSTimeHeader</font> <font color="#cc33cc">*time</font>=(<font color="#000099">DCSTimeHeader</font>
							*)data[1];<br>
							&nbsp; <font color="#000099">DCSScenarioHeader</font> <font color="#cc33cc">*scenario</font>=(<font color="#000099">DCSScenarioHeader</font>
							*)data[2];<br>
							&nbsp; <font color="#000099">DCSHeaderContainer</font> <font color="#cc33cc">*headers</font>=(<font color="#000099">DCSHeaderContainer</font>
							*)data[3];<br>
							<br>
							&nbsp; <font color="#006600">//'accept_connections' is a Boolean value controlled 
								by the program.</font><br>
							&nbsp; <font color="#3333ff">while</font>(accept_connections)<br>
							&nbsp; {<br>
							&nbsp;&nbsp; &nbsp;<font color="#006600">// First accept the connection.</font><br>
							&nbsp;&nbsp; &nbsp;<font color="#000099">SockClient</font> <font color="#cc33cc">*client</font>=<font color="#ff0000">DCSCom::serverAccept</font>(*server);<br>
							&nbsp;&nbsp; &nbsp;<font color="#3333ff">if</font>(client==NULL)<br>
							&nbsp;&nbsp; &nbsp;{<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#006600">/* Use the DCS provided 
								getSockErr() function to retrieve an error code.&nbsp;
								<br>
								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * getSockErr() returns 'errno' for UNIX 
								and the result of WSAGetLastError()
								<br>
								&nbsp; &nbsp; &nbsp; &nbsp;* for Windows. &nbsp;<br>
								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</font><br>
							&nbsp;&nbsp; &nbsp;&nbsp; printf("<font color="#663366">DCSCom::serverAccept failed 
								with error code: %d\n</font>",getSockError());<br>
							&nbsp;&nbsp; &nbsp;}<br>
							<br>
							&nbsp;&nbsp; &nbsp;<font color="#006600">/* Now negotiate the connection.&nbsp; 
								Prevent any other threads
								<br>
								&nbsp;&nbsp; &nbsp; * from modifying the data structures by locking them.&nbsp; 
								Any
								<br>
								&nbsp;&nbsp; &nbsp; * other threads that must access these data structures will
								<br>
								&nbsp;&nbsp; &nbsp; * be required to employ locks in the same manner. &nbsp;<br>
								&nbsp;&nbsp; &nbsp; */</font><br>
							&nbsp;&nbsp; &nbsp;THREAD_MUTEX_LOCK(THREAD_DATA_MUTEX);<br>
							&nbsp;&nbsp; &nbsp;<font color="#000099">bool</font> <font color="#cc33cc">success</font>=<font color="#ff0000">DCSCom::serverNegotiate</font>(*server,client,*time,*scenario,*headers);<br>
							&nbsp;&nbsp; &nbsp;THREAD_MUTEX_UNLOCK(THREAD_DATA_MUTEX);<br>
							&nbsp;&nbsp; &nbsp;<font color="#3333ff">if</font>(success)<br>
							&nbsp;&nbsp; &nbsp;{<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#000099">char</font> <font color="#cc33cc">client_address</font>[DCS_ADDRSTRLEN];<br>
							&nbsp;&nbsp; &nbsp;&nbsp; printf("<font color="#663366">Accepted connection from 
								client with address: %s\n</font>",<br>
							&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
							client-&gt;getAddress(client_address,DCS_ADDRSTRLEN));<br>
							&nbsp;&nbsp; &nbsp;}<br>
							&nbsp;&nbsp; &nbsp;<font color="#3333ff">else</font><br>
							&nbsp;&nbsp; &nbsp;{<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#006600">// The client connection must be 
								terminated.</font><br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#ff0000">DCSCom::serverTerminateClient</font>(*server,client);<br>
							&nbsp;&nbsp; &nbsp;&nbsp; printf("<font color="#663366">DCSCom::serverNegotiate 
								failed with error code: %d\n</font>",getSockError());<br>
							&nbsp;&nbsp; &nbsp;}<br>
							&nbsp; }<br>
							}</code>
						<br>
					</td>
				</tr>
			</tbody>
		</table>
		<br>
		<br>
		&nbsp;&nbsp; &nbsp;Polling for connections with a non-threaded program does not 
		require any special data locking procedures.&nbsp; The non-threaded 
		DCSCom::serverAccept example, with an invocation of the DCSCom::serverNegotiate 
		function might look like this:
		<br>
		<br>
		<br>
		<table cellpadding="2" cellspacing="0" border="1" width="750" align="center">
			<tbody>
				<tr>
					<td valign="top"><code><font color="#006600">// This example uses an infinite loop that 
								will 'exit' when the server is to be stopped.</font><br>
							<font color="#3333ff">for</font>(;;)<br>
							{<br>
							&nbsp; <font color="#006600">// 'server' is our activate DCSCom::DCSServerInfo 
								object.</font><br>
							&nbsp; <font color="#3333ff">if</font>(server.serverSocket-&gt;readReady())<br>
							&nbsp; {<br>
							&nbsp; &nbsp; <font color="#000099">SockClient</font> <font color="#cc33cc">*client</font>=<font color="#ff0000">DCSCom::serverAccept</font>(server);<br>
							&nbsp;&nbsp; &nbsp;<font color="#3333ff">if</font>(client==NULL)<br>
							&nbsp;&nbsp; &nbsp;{<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#006600">/* Use the DCS provided 
								getSockErr() function to retrieve an error code.&nbsp;
								<br>
								&nbsp; &nbsp; &nbsp; &nbsp;* getSockErr() returns 'errno' for UNIX and the 
								result of WSAGetLastError()
								<br>
								&nbsp; &nbsp; &nbsp; &nbsp;* for Windows. &nbsp;<br>
								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</font><br>
							&nbsp;&nbsp; &nbsp;&nbsp; printf("<font color="#663366">DCSCom::serverAccept failed 
								with error code: %d\n</font>",getSockError());<br>
							<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#006600">// Exit loop.</font><br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#3333ff">break</font>;<br>
							&nbsp;&nbsp; &nbsp;}<br>
							<br>
							&nbsp;&nbsp; &nbsp;<font color="#006600">// Now negotiate the connection.</font><br>
							&nbsp;&nbsp; &nbsp;<font color="#000099">bool</font> success=<font color="#ff0000">DCSCom::serverNegotiate</font>(server,client,time,scenario,headers);<br>
							&nbsp;&nbsp; &nbsp;<font color="#3333ff">if</font>(success)<br>
							&nbsp;&nbsp; &nbsp;{<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#000099">char</font> <font color="#cc33cc">client_address</font>[DCS_ADDRSTRLEN];<br>
							&nbsp;&nbsp; &nbsp;&nbsp; printf("<font color="#663366">Accepted connection from 
								client with address: %s\n</font>",<br>
							&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
							client-&gt;getAddress(client_address,DCS_ADDRSTRLEN));<br>
							&nbsp;&nbsp; &nbsp;}<br>
							&nbsp;&nbsp; &nbsp;<font color="#3333ff">else</font><br>
							&nbsp;&nbsp; &nbsp;{<br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#006600">// The client connection must be 
								terminated.</font><br>
							&nbsp;&nbsp; &nbsp;&nbsp; <font color="#ff0000">DCSCom::serverTerminateClient</font>(server,client);<br>
							&nbsp;&nbsp; &nbsp;&nbsp; printf("<font color="#663366">DCSCom::serverNegotiate 
								failed with error code: %d\n</font>",getSockError());<br>
							&nbsp;&nbsp; &nbsp;}<br>
							&nbsp; }<br>
							&nbsp; <font color="#006600">// Do other stuff.&nbsp; Break from loop when done.</font><br>
							}</code><br>
					</td>
				</tr>
			</tbody>
		</table>
		<br>
		<br>
		<h4><a name="4.1.5_Data_Management_and_Transmittal"></a>4.1.5 Data Management and 
			Transmittal</h4>
		The next step in implementing a DCS server is sending data to the client.&nbsp; 
		Once the server is listening for, accepting, and negotiating connections, it is 
		free to transmit data to any active client.&nbsp; Transmitting data to a client 
		is fairly simple.&nbsp; The data to be transmitted is first gathered from an 
		external source (file, network, etc), packaged in the appropriate DCS structure 
		as a platform, beam, or gate, and sent to the client(s) with one of the DCS 
		data transmittal functions.&nbsp; As explained in the "Data Types" section, 
		each platform, beam, and gate display object will have both a header object and 
		a data object.&nbsp; Header objects need only to be sent to the client once, 
		for initialization purposes.&nbsp; The data object is sent every time a TSPI 
		update is available for a platform, beam, or gate. &nbsp;<br>
		&nbsp;&nbsp; &nbsp;Header and data objects are associated to a specific 
		platform, beam, or gate with a unique identifier.&nbsp; The unique identifier 
		is represented by a 64-bit integer that may contain any value, as long as that 
		value is unique within the server instance.&nbsp; A practical id generation 
		scheme is one that involves taking the unique identifiers assigned to a 
		platform by its external source and combining (or-ing) them into a 64-bit 
		integer.&nbsp; The Pacific Missile Range Facility at Barking Sands, Kauai, 
		Hawaii assigns three 16-bit integers to each track that is present on its 
		iNet.&nbsp; These values indicate a vehicle id, an id for the system 
		responsible for managing the vehicle's track, and an id for the sensor 
		responsible for tracking the vehicle.&nbsp;&nbsp; When combined, these values 
		form a unique value.&nbsp; For a DCS server to process data from the PMRF iNet, 
		these three 16 bit integers could be combined to form a single unique 48-bit 
		integer.&nbsp; Similar source id to DCS id mapping techniques could be 
		developed for other organizations. &nbsp;<br>
		&nbsp;&nbsp; &nbsp;A client will not process a data object until a header 
		object has been received to initialize that data object's associated platform, 
		beam, or gate.&nbsp; For this reason, it is very important for the DCS server 
		to keep track of the headers for the platforms, beams, and gates that it has 
		encountered.&nbsp; When the server receives data for a new display object, it 
		should create a header for that object.&nbsp; The header should then be sent to 
		all of the server's active clients with one of the DCS header transmittal 
		functions, and stored in a DCSHeaderContainer for distribution to any future 
		clients at connection negotiation.&nbsp; The header objects stored in a 
		DCSHeaderContainer can be updated with each new TSPI data object.&nbsp; 
		Functions available for data transmission are:
		<ul>
			<li>
				sendPlatformHeader - Transmit a platform header object to client(s). &nbsp;</li>
			<li>
				sendBeamHeader - Transmit a beam header object to client(s). &nbsp;</li>
			<li>
				sendGateHeader - Transmit a gate header object to client(s). &nbsp;</li>
			<li>
				sendPlatformData - Transmit a platform data object to client(s). &nbsp;</li>
			<li>
				sendBeamData - Transmit a beam data object to client(s). &nbsp;</li>
			<li>
				sendGateData - Transmit a gate data object to client(s). &nbsp;</li>
			<li>
				sendEvent - Transmit an event object to client(s). &nbsp;</li>
			<li>
				sendGenericData - Transmit a generic data object to client(s). &nbsp;</li>
		</ul>
		A DCS server might process and transmit data like this:
		<br>
		<br>
		<br>
		<table cellpadding="2" cellspacing="0" border="1" width="750" align="center">
			<tbody>
				<tr>
					<td valign="top"><code><font color="#006600">/* In this example, pseudo code is used to
								<br>
								&nbsp;* represented functions for processing and interpreting external
								<br>
								&nbsp;* data.&nbsp; These pseudo code functions, which appear with all letters
								<br>
								&nbsp;* capitalized, are not provided by DCS and must be supplied by
								<br>
								&nbsp;* a particular DCS server's implementer. &nbsp;<br>
								&nbsp;*/</font><br>
							<br>
							<font color="#006600">//Read external data.</font><br>
							<font color="#000099">EXTERNAL_DATA_TYPE</font> <font color="#cc33cc">*ext_data</font>=GET_EXTERNAL_DATA();<br>
							<br>
							<font color="#006600">// Make our DCS id.</font><br>
							<font color="#000099">int64_t</font> <font color="#cc33cc">dcs_id</font>=<font color="#ff0000">DCS::make_id</font>(0,ext_data-&gt;vid,ext_data-&gt;sid,ext_data-&gt;sysid);<br>
							&nbsp;&nbsp; &nbsp;<br>
							<font color="#006600">/* Get the header for our data.&nbsp; The 
								DCSHeaderContainer::retrieve function
								<br>
								&nbsp;* will take the id of the header object to be retrieved and an optional
								<br>
								&nbsp;* structure to be filled with the retrieved data as arguments.&nbsp; If 
								the optional
								<br>
								&nbsp;* structure argument is supplied, the appropriate field (platform, beam, 
								or
								<br>
								&nbsp;* gate) will be filled with the retrieved data and a pointer to that 
								field will
								<br>
								&nbsp;* be returned to the calling process.&nbsp; If the optional structure 
								argument is
								<br>
								&nbsp;* NULL, the DCSHeaderContainer::retrieve function will allocate the 
								memory<br>
								&nbsp;* for the appropriate header object (platform, beam, or gate) with 'new' 
								and return
								<br>
								&nbsp;* a pointer to that object.&nbsp; The calling process is responsible for 
								releasing any<br>
								&nbsp;* memory allocated by the DCSHeaderContainer::retrieve function with 
								'delete'. &nbsp;<br>
								&nbsp;*/</font><br>
							<font color="#000099">DCSHeaderGroup</font> <font color="#cc33cc">header_objects</font>;<br>
							<font color="#000099">DCSBaseHeader</font> <font color="#cc33cc">*header</font>=<font color="#ff0000">header_container.retrieve</font>(dcs_id,&amp;header_objects);<br>
							<br>
							<font color="#006600">// If 'NULL' was returned, the header does not yet exist.</font><br>
							<font color="#3333ff">if</font>(header==NULL)<br>
							{<br>
							&nbsp; <font color="#006600">//This is a new track.&nbsp; Create a header for it.</font><br>
							&nbsp; header=GENERATE_HEADER(ext_data);<br>
							}<br>
							<br>
							<font color="#006600">/* Now update our header's TSPI data.&nbsp; If the header was 
								just created
								<br>
								&nbsp;* this will be it's initial data object. &nbsp;<br>
								&nbsp;* /</font><br>
							<font color="#3333ff">switch</font>(header-&gt;getType())<br>
							{<br>
							<font color="#006600">//Generate data for a platform.</font><br>
							<font color="#3333ff">case</font> DCSPLATFORMHEADER:<br>
							&nbsp; <font color="#006600">// Copy platform data from the external data structure 
								to the header.</font><br>
							&nbsp; ((<font color="#000099">DCSPlatformHeader</font>*)header)-&gt;platdata_=GENERATE_PLATFORM_DATA(ext_data);<br>
							&nbsp; <font color="#3333ff">break</font>;<br>
							<br>
							<font color="#006600">//Generate data for a beam.</font><br>
							<font color="#3333ff">case</font> DCSBEAMHEADER:<br>
							&nbsp; <font color="#006600">// Copy beam data from the external data structure to 
								the header.</font><br>
							&nbsp; ((<font color="#000099">DCSBeamHeader</font>*)header)-&gt;beamdata_=GENERATE_BEAM_DATA(ext_data);<br>
							&nbsp; <font color="#3333ff">break</font>;<br>
							<br>
							<font color="#006600">//Generate data for a gate.</font><br>
							<font color="#3333ff">case</font> DCSGATEHEADER:<br>
							&nbsp; <font color="#006600">// Copy gate data from the external data structure to 
								the header.</font><br>
							&nbsp; ((<font color="#000099">DCSGateHeader</font>*)header)-&gt;gatedata_=GENERATE_GATE_DATA(ext_data);<br>
							&nbsp; <font color="#3333ff">break</font>;<br>
							<br>
							<font color="#3333ff">default</font>:<br>
							&nbsp; <font color="#006600">// Handle error.</font><br>
							}<br>
							<br>
							<font color="#006600">/* After the header's data field has been updated, update the 
								header's record
								<br>
								&nbsp;* in the header container.&nbsp; If the DCSHeaderContainer::update 
								function indicates
								<br>
								&nbsp;* that this is a new header, distribute it to client(s). &nbsp;<br>
								&nbsp;*/</font><br>
							<font color="#000099">bool</font> <font color="#cc33cc">existed</font>;<br>
							<font color="#ff0000">header_container.update</font>(header,exists);<br>
							<br>
							<font color="#006600">// 'existed' is false if this is a new platform.</font><br>
							<font color="#3333ff">if</font>(!existed)<br>
							{<br>
							&nbsp; <font color="#006600">//This is a new header.&nbsp; Distribute to client(s).</font><br>
							&nbsp; <font color="#3333ff">switch</font>(header-&gt;getType())<br>
							&nbsp; {<br>
							&nbsp; <font color="#3333ff">case</font> DCSPLATFORMHEADER:<br>
							&nbsp; &nbsp; <font color="#ff0000">DCSCom::sendPlatformHeader</font>(server,header);<br>
							&nbsp; &nbsp; <font color="#3333ff">break</font>;<br>
							&nbsp; <font color="#3333ff">case</font> DCSBEAMHEADER:<br>
							&nbsp; &nbsp; <font color="#ff0000">DCSCom::sendBeamHeader</font>(server,header);<br>
							&nbsp; &nbsp; <font color="#3333ff">break</font>;<br>
							&nbsp; <font color="#3333ff">case</font> DCSGATEHEADER:<br>
							&nbsp; &nbsp; <font color="#ff0000">DCSCom::sendGateHeader</font>(server,header);<br>
							&nbsp; &nbsp; <font color="#3333ff">break</font>;<br>
							&nbsp; <font color="#3333ff">default</font>:<br>
							&nbsp; &nbsp; <font color="#006600">// Handle error.</font><br>
							&nbsp; }<br>
							}<br>
							<br>
							<font color="#006600">/* Send the headers data field to the client(s).&nbsp; The 
								data field
								<br>
								&nbsp;* is actually a DCSPlatformData, DCSBeamData, or DCSGateData
								<br>
								&nbsp;* object embedded in the header object. &nbsp;<br>
								&nbsp;*/<br>
							</font><font color="#3333ff">switch</font>(header-&gt;getType())<br>
							{<br>
							<font color="#3333ff">case</font> DCSPLATFORMHEADER:<br>
							&nbsp; <font color="#ff0000">DCSCom::sendPlatformData</font>(server,((<font color="#000099">DCSPlatformHeader</font>*)header)-&gt;platdata_);<br>
							&nbsp; <font color="#3333ff">break</font>;<br>
							<font color="#3333ff">case</font> DCSBEAMHEADER:<br>
							&nbsp; <font color="#ff0000">DCSCom::sendBeamData</font>(server,((<font color="#000099">DCSBeamHeader</font>*)header)-&gt;beamdata_);<br>
							&nbsp; <font color="#3333ff">break</font>;<br>
							<font color="#3333ff">case</font> DCSGATEHEADER:<br>
							&nbsp; <font color="#ff0000">DCSCom::sendGateData</font>(server,((<font color="#000099">DCSGateHeader</font>*)header)-&gt;gatedata_);<br>
							&nbsp; <font color="#3333ff">break</font>;<br>
							<font color="#3333ff">default</font>:<br>
							&nbsp; <font color="#006600">// Handle error.</font><br>
							}</code>
						<br>
					</td>
				</tr>
			</tbody>
		</table>
		<br>
		<br>
		<h4><a name="4.1.6_Server_Completion"></a> 4.1.6 Server Completion</h4>
		Stopping the server is the final step involved in the implementation of a DCS 
		server*.&nbsp; This is also the simplest step, accomplished by invoking the 
		DCSCom::serverStop function.&nbsp; When the server is stopped, it will stop 
		listening for client connections and will stop sending UDP data.&nbsp; Any 
		network resources acquired by the server will be released, and any memory 
		allocated for the DCSServerInfo structure by the DCSCom::startServer function 
		will be freed.&nbsp; An invocation of the DCSCom::serverStop function might 
		look like this:<br>
		<br>
		<br>
		<table cellpadding="2" cellspacing="0" border="1" width="750" align="center">
			<tbody>
				<tr>
					<td valign="top"><code><font color="#006600"> // Stop the server and release any allocated 
								system resources.</font><br>
							<font color="#ff0000">DCSCom::serverStop</font>(server);</code></td>
				</tr>
			</tbody>
		</table>
		<br>
		<br>
		* For Microsoft Windows based applications this is actually the second to last 
		step. &nbsp;Before the application exits it must release the resources 
		allocated for the Winsock DLL by the 'initializeSocket()' function. &nbsp;A 
		function called 'finalizeSocket()' is provided with the DCS API for this 
		purpose. &nbsp;The 'finalizeSocket()' function should be called once before 
		program exit. &nbsp;<br>
		&nbsp;
		<h4><a name="4.1.7_Further_Reading"></a> 4.1.7 Further Reading</h4>
		A detailed description of the DCS data types and the DCS Server API functions 
		and their parameters can be found in the DCS Reference Documentation.&nbsp; A 
		working C++ sample of a simple DCS server implementation is also included with 
		the DCS library. &nbsp;<br>
		<br>
		<h3><a name="4.2_DCS_Client_API"></a>4.2 DCS Client API</h3>
		TBD<br>
		<br>
		<br>
		<h2><a name="5.0_Server_Discovery"></a>5.0 Server Discovery</h2>
		TBD<br>
		<br>
		<h3><a name="5.1_Discovery_Server_API"></a>5.1 Discovery Server API</h3>
		TBD<br>
		<br>
		<h3><a name="5.2_Discovery_Client_API"></a>5.2 Discovery Client API</h3>
		TBD<br>
		<br>
		<br>
		<h2><a name="6.0_Using_the_Library"></a>6.0 Using the Library</h2>
		The DCS and NET libraries, distributed with the DCS package, are required for 
		implementing programs for use with the DCS API. &nbsp;The DCS library provides 
		a C++ implementation of the DCS protocol, while the NET library provides the 
		lower level TCP and UDP communication functionality. &nbsp;Creating an 
		application with the DCS API requires the inclusion of DCS related header 
		files, linkage with DCS and NET library files, and some build configuration 
		settings. &nbsp;<br>
		<br>
		<h3><a name="6.1_Required_Files"></a>6.1 Required Files</h3>
		Programs designed to work with the DCS API are required to include the 'DCS.h' 
		header file. &nbsp;This file includes all of the necessary DCS, NET, and other 
		miscellaneous header files required for the implementation of a DCS 
		application. &nbsp;These header files define all of the types and functions 
		provided by the DCS API. &nbsp; Any C++ source file that makes use of the DCS 
		API must include this line:<br>
		<br>
		<table cellpadding="2" cellspacing="0" border="1" width="750" align="center">
			<tbody>
				<tr>
					<td valign="top"><font color="#cc0000">#include</font> "<font color="#663366">DCS.h</font>"<br>
					</td>
				</tr>
			</tbody>
		</table>
		<br>
		&nbsp;&nbsp;&nbsp; Programs designed to work with the DCS API must also be 
		linked with the proper DCS and NET library files. &nbsp;For Microsoft Windows 
		based applications, these libraries are DCS.lib and NET.lib, and for UNIX based 
		applications these libraries are libDCS.a and libNET.a. &nbsp;Microsoft Visual 
		Studio users can link their applications with these libraries by adding them to 
		the "Object/library modules" text field from the "Link" tab of the project 
		settings dialog. &nbsp;UNIX makefile users can link their applications with 
		these libraries by adding -lDCS and -lNET to the linker options. &nbsp;<br>
		<h3><a name="6.2_Build_Configuration"></a>6.2 Build Configuration</h3>
		Programs using the DCS libraries must include certain build configuration items 
		to ensure proper compilation and execution. &nbsp;The locations of the DCS 
		header files and libraries must be specified, and some preprocessor directives 
		must be defined. &nbsp;To successfully compile an application with the DCS 
		header files and libraries, the compiler must be told where the necessary files 
		are located. &nbsp;Microsoft Visual Studio users can specify the appropriate 
		file locations with the project settings dialog, using the "Additional include 
		directories" text field from the "Preprocessor" section of the "C/C++" tab to 
		specify the locations of the required header files, and the "Additional library 
		path" text field from the "Input" section of the "Link" tab to specify the to 
		specify the locations of the required libraries. &nbsp;Unix makefile users can 
		specify the locations of the required header files with the "-I" compiler 
		option, and the locations of the required libraries with the "-L" compiler 
		option. &nbsp;When compiling a program that makes use of the DCS API, use these 
		procedures to specify the directories in which the header files and libraries 
		are installed. &nbsp;<br>
		&nbsp;&nbsp;&nbsp; To successfully create a properly functioning DCS based 
		program, some preprocessor definitions must be made to identify the platform 
		for which the program is being created. &nbsp;These preprocessor definitions 
		specify the byte order for the DCS program's target architecture. 
		&nbsp;Microsoft Visual Studio Users can specify the appropriate preprocessor 
		definitions with the project settings dialog, using the "Preprocessor 
		definitions" text field from the "Preprocessor" section of the "C/C++" tab. 
		&nbsp;Unix makefile users can specify the appropriate preprocessor definitions 
		with the "-D" compiler option. &nbsp;The available preprocessor definitions are 
		SIM_LITTLE_ENDIAN, SIM_BIG_ENDIAN, X86, WIN32, Linux, and Solaris. 
		&nbsp;The SIM_LITTLE_ENDIAN and SIM_BIG_ENDIAN preprocessor definitions specify 
		the byte order of the target architecture for the DCS based application. 
		&nbsp;Systems with Intel x86 based processors use the Little Endian byte order 
		(this includes AMD and Cyrix processors) and should define SIM_LITTLE_ENDIAN. 
		&nbsp;Most Unix systems have processors that use the Big Endian byte order 
		(e.g. MIPS, SPARC) and should define SIM_BIG_ENDIAN. &nbsp;Systems with Alpha 
		processors also use the Little Endian byte order, although the DCS API does not 
		officially support Alpha systems. &nbsp;The X86, WIN32, Linux, and Solaris
                preprocessor definitions specify the target operating system for the DCS 
		based application. &nbsp;Microsoft Windows users should define X86 and WIN32, 
		Linux users should define Linux, Sun SOLARIS users should define Solaris.
                &nbsp;Linux users should also define X86 when using an Intel x86 based system.
                &nbsp;Although the Alpha based systems are not officially supported, the ALPHA
                preprocessor definition for Alpha based systems exists. &nbsp;<br>
		&nbsp;&nbsp;&nbsp; The following table matches architectures and operating 
		systems with the appropriate preprocessor definitions:<br>
		<br>
		<br>
		<table cellpadding="2" cellspacing="2" border="1" width="800" align="center">
			<tbody>
				<tr>
					<td valign="middle" colspan="2" rowspan="2" bgcolor="#999999" align="center">Preprocessor<br>
						Definitions<br>
					</td>
					<td valign="top" colspan="3" align="center" bgcolor="#c0c0c0">Architecture<br>
					</td>
				</tr>
				<tr>
					<td valign="top" bgcolor="#cccccc" align="center">Intel x86<br>
					</td>
					<td valign="top" bgcolor="#cccccc" align="center">SPARC<br>
					</td>
				</tr>
				<tr>
					<td valign="middle" rowspan="4" colspan="1" bgcolor="#c0c0c0">OS<br>
					</td>
					<td valign="top" bgcolor="#cccccc">Microsoft Windows<br>
					</td>
					<td valign="top">X86, WIN32, SIM_LITTLE_ENDIAN<br>
					</td>
					<td valign="top" align="center">-<br>
					</td>
				</tr>
				<tr>
					<td valign="top" bgcolor="#cccccc">Linux<br>
					</td>
					<td valign="top">X86, Linux, SIM_LITTLE_ENDIAN<br>
					</td>
					<td valign="top">Linux, SIM_BIG_ENDIAN*<br>
					</td>
				</tr>
				<tr>
					<td valign="top" bgcolor="#cccccc">SOLARIS<br>
					</td>
					<td valign="top">Solaris, SIM_LITTLE_ENDIAN*<br>
					</td>
					<td valign="top">Solaris, SIM_BIG_ENDIAN<br>
					</td>
				</tr>
			</tbody>
		</table>
		<br>
		* These systems are not officially supported by the DCS API. &nbsp;<br>
		<br>
		<br>
	</body>
</html>
 </div></div><!-- contents -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title></title>
   
</head>
  <body>
           
<hr>    <br>
      2002-2008 U.S. Naval Research Laboratory. &nbsp;The 
U.S. Government retains   all rights  to use, duplicate, distribute, disclose,
 or release this document.   &nbsp;<br>
         <br>
         For further information regarding DCS or SIMDIS please visit <a
 href="https://simdis.nrl.navy.mil">https://simdis.nrl.navy.mil</a> or send e-mail to <a
 href="mailto:simdis@enews.nrl.navy.mil">simdis@enews.nrl.navy.mil</a>. &nbsp;<br>
         <br>
         Copies of DCS and SIMDIS, as well as this manual and other related 
 information,&nbsp;    may be obtained from <a
 href="https://simdis.nrl.navy.mil">https://simdis.nrl.navy.mil</a>.    &nbsp;<br>
         <br>
                 
<hr width="100%" size="2">   
<address><small>Generated at Mon Mar 26 2012 08:06:29 for the DCS API by <a
 href="http://www.stack.nl/%7Edimitri/doxygen/index.html">doxygen</a> 1.7.6.1.</small></address>
 <br>
 <br>
 <br>
 
</body>
</html>
